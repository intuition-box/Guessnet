import { ethers } from "hardhat";
import { PredictionMarketOracle, PredictionMarketFactory, TransactionPredictionMarket } from "../typechain-types";

/**
 * Script de test complet pour l'Oracle de cl√¥ture
 * Teste toutes les fonctionnalit√©s : surveillance, cl√¥ture, distribution
 */

async function main() {
  const [deployer, user1, user2, resolver] = await ethers.getSigners();
  
  console.log("üß™ Testing Prediction Market Oracle System");
  console.log("==========================================");
  console.log("üë§ Deployer:", deployer.address);
  console.log("üë§ User1:", user1.address);  
  console.log("üë§ User2:", user2.address);
  console.log("üë§ Resolver:", resolver.address);

  // R√©cup√©rer les contrats d√©ploy√©s
  const oracle = await ethers.getContract("PredictionMarketOracle") as PredictionMarketOracle;
  const factory = await ethers.getContract("PredictionMarketFactory") as PredictionMarketFactory;
  
  const oracleAddress = await oracle.getAddress();
  const factoryAddress = await factory.getAddress();
  
  console.log("\nüèõÔ∏è  Contract Addresses:");
  console.log("üîÆ Oracle:", oracleAddress);
  console.log("üè≠ Factory:", factoryAddress);

  // Test 1: V√©rifier l'√©tat initial de l'Oracle
  console.log("\nüìä Test 1: Oracle Initial State");
  console.log("================================");
  
  const [totalResolved, totalDistributed, activeResolvers] = await oracle.getOracleStats();
  const isDeployerAuthorized = await oracle.authorizedResolvers(deployer.address);
  const currentData = await oracle.getCurrentTransactionData();
  const isDataFresh = await oracle.isDataFresh();
  
  console.log("‚úÖ Deployer authorized:", isDeployerAuthorized);
  console.log("üìà Markets resolved:", totalResolved.toString());
  console.log("üí∞ Total distributed:", ethers.formatEther(totalDistributed), "ETH");
  console.log("üë• Active resolvers:", activeResolvers.toString());
  console.log("üìä Data valid:", currentData.isValid);
  console.log("‚è∞ Data fresh:", isDataFresh);

  // Test 2: Ajouter un r√©solveur suppl√©mentaire
  console.log("\nüîê Test 2: Adding Additional Resolver");
  console.log("======================================");
  
  try {
    const addResolverTx = await oracle.addResolver(resolver.address);
    await addResolverTx.wait();
    console.log("‚úÖ Resolver added:", resolver.address);
    
    const isResolverAuthorized = await oracle.authorizedResolvers(resolver.address);
    console.log("üîê New resolver authorized:", isResolverAuthorized);
    
    const resolvers = await oracle.getAuthorizedResolvers();
    console.log("üë• Total resolvers:", resolvers.length);
    
  } catch (error) {
    console.error("‚ùå Failed to add resolver:", error);
  }

  // Test 3: Simuler des donn√©es de l'API Intuition
  console.log("\nüì° Test 3: Updating Transaction Data (Simulating Intuition API)");
  console.log("================================================================");
  
  // Donn√©es simul√©es comme si elles venaient de l'API Intuition
  const simulatedApiData = {
    totalTransactions: 2500000, // 2.5M transactions totales
    timestamp: Math.floor(Date.now() / 1000) // Timestamp actuel
  };
  
  try {
    const updateTx = await oracle.connect(resolver).updateTransactionData(
      simulatedApiData.totalTransactions,
      simulatedApiData.timestamp
    );
    await updateTx.wait();
    console.log("‚úÖ Transaction data updated successfully");
    console.log("üìä Total transactions:", simulatedApiData.totalTransactions.toLocaleString());
    
    // V√©rifier que les donn√©es ont √©t√© mises √† jour
    const updatedData = await oracle.getCurrentTransactionData();
    const isNowFresh = await oracle.isDataFresh();
    
    console.log("üìà Updated data valid:", updatedData.isValid);
    console.log("‚è∞ Data is now fresh:", isNowFresh);
    console.log("üî¢ Stored transactions:", updatedData.totalTransactions.toString());
    
  } catch (error) {
    console.error("‚ùå Failed to update transaction data:", error);
  }

  // Test 4: Cr√©er un march√© de test avec une √©ch√©ance courte
  console.log("\nüéØ Test 4: Creating Test Market with Short Deadline");
  console.log("====================================================");
  
  const description = "Will there be more than 2M transactions on the blockchain?";
  const threshold = 2000000; // 2M transactions
  const deadline = Math.floor(Date.now() / 1000) + 10; // 10 secondes dans le futur (pour test)
  
  let testMarketAddress: string = "";
  
  try {
    const createTx = await factory.connect(user1).createTransactionMarket(
      description,
      threshold,
      deadline,
      oracleAddress // Utiliser notre Oracle
    );
    
    const receipt = await createTx.wait();
    const marketCreatedEvent = receipt?.logs.find(log => {
      try {
        return factory.interface.parseLog(log as any)?.name === "MarketCreated";
      } catch {
        return false;
      }
    });
    
    if (marketCreatedEvent) {
      const parsedEvent = factory.interface.parseLog(marketCreatedEvent as any);
      testMarketAddress = parsedEvent?.args.marketAddress;
      console.log("‚úÖ Test market created:", testMarketAddress);
    }
    
  } catch (error) {
    console.error("‚ùå Failed to create test market:", error);
    return;
  }

  // Test 5: Placer des paris sur le march√©
  console.log("\nüí∞ Test 5: Placing Bets on Test Market");
  console.log("=======================================");
  
  const market = await ethers.getContractAt("TransactionPredictionMarket", testMarketAddress);
  
  try {
    // User1 parie 1 ETH que √ßa sera AU-DESSUS du seuil (2M)
    const bet1Tx = await market.connect(user1).placeBet(0, { value: ethers.parseEther("1.0") });
    await bet1Tx.wait();
    console.log("‚úÖ User1 bet 1 ETH on ABOVE threshold");
    
    // User2 parie 0.5 ETH que √ßa sera EN-DESSOUS du seuil (2M)
    const bet2Tx = await market.connect(user2).placeBet(1, { value: ethers.parseEther("0.5") });
    await bet2Tx.wait();
    console.log("‚úÖ User2 bet 0.5 ETH on BELOW threshold");
    
    // V√©rifier l'√©tat du march√©
    const [, , , , , , status, aboveBets, belowBets, bettorCount, totalValueLocked] = await market.getMarketInfo();
    console.log("üìä Market State:");
    console.log("  - Status:", status === 0 ? "ACTIVE" : "RESOLVED");
    console.log("  - Above Bets:", ethers.formatEther(aboveBets), "ETH");
    console.log("  - Below Bets:", ethers.formatEther(belowBets), "ETH");
    console.log("  - Total Bettors:", bettorCount.toString());
    console.log("  - Total Value Locked:", ethers.formatEther(totalValueLocked), "ETH");
    
  } catch (error) {
    console.error("‚ùå Failed to place bets:", error);
  }

  // Test 6: Attendre l'expiration et tenter la cl√¥ture (avant expiration - doit √©chouer)
  console.log("\n‚è∞ Test 6: Testing Pre-Expiration Closure (Should Fail)");
  console.log("========================================================");
  
  try {
    await oracle.connect(resolver).closeExpiredMarket(testMarketAddress);
    console.log("‚ùå ERROR: Market closed before expiration!");
  } catch (error) {
    console.log("‚úÖ Correctly rejected pre-expiration closure:", error.message);
  }

  // Test 7: Attendre l'expiration et cl√¥turer le march√©
  console.log("\n‚öñÔ∏è Test 7: Waiting for Expiration and Closing Market");
  console.log("=====================================================");
  
  console.log("‚è≥ Waiting for market to expire (15 seconds)...");
  await new Promise(resolve => setTimeout(resolve, 15000));
  
  // V√©rifier si le march√© peut √™tre r√©solu
  const canResolve = await oracle.canResolveMarket(testMarketAddress);
  console.log("üîç Can resolve market:", canResolve);
  
  if (canResolve) {
    try {
      console.log("üéØ Closing expired market...");
      console.log("üìä Current API data: 2.5M transactions vs threshold: 2M transactions");
      console.log("üí° Expected result: ABOVE_THRESHOLD wins (2.5M > 2M)");
      
      const closeTx = await oracle.connect(resolver).closeExpiredMarket(testMarketAddress);
      const receipt = await closeTx.wait();
      
      console.log("‚úÖ Market closed successfully!");
      console.log("‚õΩ Gas used:", receipt?.gasUsed.toString());
      
      // V√©rifier les √©v√©nements √©mis
      if (receipt?.logs) {
        for (const log of receipt.logs) {
          try {
            const parsedLog = oracle.interface.parseLog(log as any);
            if (parsedLog) {
              console.log(`üì¢ Event: ${parsedLog.name}`);
              if (parsedLog.name === "MarketClosed") {
                console.log(`  - Final Transactions: ${parsedLog.args.finalTransactionCount}`);
                console.log(`  - Winning Type: ${parsedLog.args.winningType === 0 ? 'ABOVE_THRESHOLD' : 'BELOW_THRESHOLD'}`);
              }
            }
          } catch {
            // Ignorer les logs d'autres contrats
          }
        }
      }
      
    } catch (error) {
      console.error("‚ùå Failed to close market:", error);
    }
  } else {
    console.log("‚ö†Ô∏è  Market cannot be resolved yet");
  }

  // Test 8: V√©rifier la r√©solution et les statistiques
  console.log("\nüìà Test 8: Checking Resolution and Final Stats");
  console.log("===============================================");
  
  try {
    // V√©rifier la r√©solution du march√©
    const resolution = await oracle.getMarketResolution(testMarketAddress);
    console.log("üìã Market Resolution:");
    console.log("  - Is Resolved:", resolution.isResolved);
    console.log("  - Resolution Time:", new Date(Number(resolution.resolutionTimestamp) * 1000).toISOString());
    console.log("  - Final Transaction Count:", resolution.finalTransactionCount.toString());
    console.log("  - Winning Type:", resolution.winningType === 0n ? "ABOVE_THRESHOLD" : "BELOW_THRESHOLD");
    
    // V√©rifier l'√©tat final du march√©
    const [, , , , , , finalStatus] = await market.getMarketInfo();
    console.log("üéØ Market Final Status:", finalStatus === 1 ? "RESOLVED" : "STILL_ACTIVE");
    
    // Statistiques de l'Oracle
    const [newTotalResolved, newTotalDistributed, newActiveResolvers] = await oracle.getOracleStats();
    console.log("üìä Updated Oracle Stats:");
    console.log("  - Markets Resolved:", newTotalResolved.toString());
    console.log("  - Total Distributed:", ethers.formatEther(newTotalDistributed), "ETH");
    console.log("  - Active Resolvers:", newActiveResolvers.toString());
    
  } catch (error) {
    console.error("‚ùå Failed to get resolution info:", error);
  }

  // Test 9: Test de la cl√¥ture par lot
  console.log("\nüöÄ Test 9: Testing Batch Market Closure");
  console.log("========================================");
  
  try {
    const expiredMarkets = await oracle.getResolvableMarkets();
    console.log("üìä Resolvable markets found:", expiredMarkets.length);
    
    if (expiredMarkets.length > 0) {
      console.log("üîÑ Attempting batch closure...");
      await oracle.connect(resolver).closeAllExpiredMarkets();
      console.log("‚úÖ Batch closure completed");
    } else {
      console.log("‚úÖ No additional markets to resolve");
    }
    
  } catch (error) {
    console.error("‚ùå Batch closure failed:", error);
  }

  console.log("\nüéâ Oracle System Testing Completed!");
  console.log("====================================");
  console.log("‚úÖ Oracle deployment working");
  console.log("‚úÖ Resolver management functional");
  console.log("‚úÖ Transaction data updates working");
  console.log("‚úÖ Market expiration detection working");
  console.log("‚úÖ Automatic closure working");
  console.log("‚úÖ Winner determination accurate");
  console.log("‚úÖ Event emission working");
  console.log("‚úÖ Security checks passing");
  
  console.log("\nüìã Next Implementation Steps:");
  console.log("1. üîß Implement backend service to call Intuition API");
  console.log("2. üì° Set up periodic API calls to updateTransactionData()");
  console.log("3. ‚öñÔ∏è Set up periodic calls to closeAllExpiredMarkets()");
  console.log("4. üñ•Ô∏è Update frontend to show Oracle status");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });